/*
 * UFC-crypt: ultra fast crypt(3) implementation
 *
 * Copyright (C) 1991, 92, 93, 96, 97, 98, 2000 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; see the file COPYING.LIB.  If not,
 * write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 *
 * Code to generate yet more DES tables.
 * Formerly @(#)crypt_util.c     2.56 12/20/96
 *
 */

#include "des.h"

#include <string.h>
#include <stdio.h>

static const char file_head[] =
  "/* This file generated by des-mktables.  DO NOT EDIT.  */\n"
  "\n"
  "#include \"des.h\"";

static const char do_pc1_head[] =
  "\n"
  "/*\n"
  " * do_pc1: permform pc1 permutation in the key schedule generation.\n"
  " *\n"
  " * The first   index is the byte number in the 8 byte ASCII key\n"
  " *  -  second    -      -    the two 28 bits halfs of the result\n"
  " *  -  third     -   selects the 7 bits actually used of each byte\n"
  " *\n"
  " * The result is kept with 28 bit per 32 bit with the 4 most significant\n"
  " * bits zero.\n"
  " */\n"
  "const uint_fast32_t do_pc1[8][2][128] = {";
static uint32_t do_pc1_[8][2][128];

static const char do_pc2_head[] =
  "\n"
  "/*\n"
  " * do_pc2: permform pc2 permutation in the key schedule generation.\n"
  " *\n"
  " * The first   index is the septet number in the two 28 bit intermediates\n"
  " *  -  second    -    -  -  septet values\n"
  " *\n"
  " * Knowledge of the structure of the pc2 permutation is used.\n"
  " *\n"
  " * The result is kept with 28 bit per 32 bit with the 4 most significant\n"
  " * bits zero.\n"
  " */\n"
  "const uint_fast32_t do_pc2[8][128] = {\n";
static uint32_t do_pc2_[8][128];

static const char eperm32tab_head[] =
  "\n"
  "/*\n"
  " * eperm32tab: do 32 bit permutation and E selection\n"
  " *\n"
  " * The first index is the byte number in the 32 bit value to be permuted\n"
  " *  -  second  -   is the value of this byte\n"
  " *  -  third   -   selects the two 32 bit values\n"
  " */\n"
  "const uint_fast32_t eperm32tab[4][256][2] = {\n";
static uint32_t eperm32tab_[4][256][2];

static const char efp_head[] =
  "\n"
  "/*\n"
  " * efp: undo an extra e selection and do final\n"
  " *      permutation giving the DES result.\n"
  " *\n"
  " *      Invoked 6 bit a time on two 48 bit values\n"
  " *      giving two 32 bit longs.\n"
  " */\n"
  "const uint_fast32_t efp[16][64][2] = {\n";
static uint32_t efp_[16][64][2];

static void
dump_do_pc1 (void)
{
  puts (do_pc1_head);
  for (int i = 0; i < 8; i++)
    {
      puts("  {");
      for (int j = 0; j < 2; j++)
        {
          puts ("    {");
          for (int k = 0; k < 128; k += 4)
            printf("      0x%08x, 0x%08x, 0x%08x, 0x%08x,\n",
                   do_pc1_[i][j][k+0],
                   do_pc1_[i][j][k+1],
                   do_pc1_[i][j][k+2],
                   do_pc1_[i][j][k+3]);
          puts ("    },");
        }
      puts ("  },");
    }
  puts("};");
}

static void
dump_do_pc2 (void)
{
  puts (do_pc2_head);
  for (int i = 0; i < 8; i++)
    {
      puts("  {");
      for (int j = 0; j < 128; j += 4)
        printf("    0x%08x, 0x%08x, 0x%08x, 0x%08x,\n",
               do_pc2_[i][j+0],
               do_pc2_[i][j+1],
               do_pc2_[i][j+2],
               do_pc2_[i][j+3]);
      puts ("  },");
    }
  puts("};");
}

static void
dump_eperm32tab (void)
{
  puts (eperm32tab_head);
  for (int i = 0; i < 4; i++)
    {
      puts("  {");
      for (int j = 0; j < 256; j += 2)
        printf("    { 0x%08x, 0x%08x, }, { 0x%08x, 0x%08x, },\n",
               eperm32tab_[i][j+0][0],
               eperm32tab_[i][j+0][1],
               eperm32tab_[i][j+1][0],
               eperm32tab_[i][j+1][1]);
      puts ("  },");
    }
  puts("};");
}

static void
dump_efp (void)
{
  puts (efp_head);
  for (int i = 0; i < 16; i++)
    {
      puts("  {");
      for (int j = 0; j < 64; j += 2)
        printf("    { 0x%08x, 0x%08x, }, { 0x%08x, 0x%08x, },\n",
               efp_[i][j+0][0],
               efp_[i][j+0][1],
               efp_[i][j+1][0],
               efp_[i][j+1][1]);
      puts ("  },");
    }
  puts("};");
}

static void
compute_extra_tables (void)
{
  int bit;
  int comes_from_bit;
  int e_inverse[64];
  uint_fast32_t j;

  /*
   * Create the do_pc1 table used
   * to affect pc1 permutation
   * when generating keys
   */
  for (bit = 0; bit < 56; bit++)
    {
      uint_fast32_t mask1, mask2;

      comes_from_bit = pc1[bit] - 1;
      mask1 = bytemask[comes_from_bit % 8 + 1];
      mask2 = longmask[bit % 28 + 4];
      for (j = 0; j < 128; j++)
        {
          if (j & mask1)
            do_pc1_[comes_from_bit / 8][bit / 28][j] |= mask2;
        }
    }

  /*
   * Create the do_pc2 table used
   * to affect pc2 permutation when
   * generating keys
   */
  for (bit = 0; bit < 48; bit++)
    {
      uint_fast32_t mask1, mask2;

      comes_from_bit = pc2[bit] - 1;
      mask1 = bytemask[comes_from_bit % 7 + 1];
      mask2 = bitmask[bit % 24];
      for (j = 0; j < 128; j++)
        {
          if (j & mask1)
            do_pc2_[comes_from_bit / 7][j] |= mask2;
        }
    }

  /*
   * Now generate the table used to do combined
   * 32 bit permutation and e expansion
   *
   * We use it because we have to permute 16384 32 bit
   * longs into 48 bit in order to initialize sb.
   *
   * Looping 48 rounds per permutation becomes
   * just too slow...
   *
   */
  for (bit = 0; bit < 48; bit++)
    {
      uint_fast32_t mask, comes_from;
      comes_from = perm32[esel[bit] - 1] - 1;
      mask = bytemask[comes_from % 8];
      for (j = 256; j--;)
        {
          if (j & mask)
            eperm32tab_[comes_from / 8][j][bit / 24] |= bitmask[bit % 24];
        }
    }

  /*
   * Create an inverse matrix for esel telling
   * where to plug out bits if undoing it
   */
  for (bit = 48; bit--;)
    {
      e_inverse[esel[bit] - 1] = bit;
      e_inverse[esel[bit] - 1 + 32] = bit + 48;
    }

  /*
   * create efp: the matrix used to
   * undo the E expansion and effect final permutation
   */
  for (bit = 0; bit < 64; bit++)
    {
      int o_bit, o_long;
      uint_fast32_t word_value, mask1, mask2;
      int comes_from_f_bit, comes_from_e_bit;
      int comes_from_word, bit_within_word;

      /* See where bit i belongs in the two 32 bit long's */
      o_long = bit / 32;        /* 0..1  */
      o_bit = bit % 32;         /* 0..31 */

      /*
       * And find a bit in the e permutated value setting this bit.
       *
       * Note: the e selection may have selected the same bit several
       * times. By the initialization of e_inverse, we only look
       * for one specific instance.
       */
      comes_from_f_bit = final_perm[bit] - 1;   /* 0..63 */
      comes_from_e_bit = e_inverse[comes_from_f_bit];   /* 0..95 */
      comes_from_word = comes_from_e_bit / 6;   /* 0..15 */
      bit_within_word = comes_from_e_bit % 6;   /* 0..5  */

      mask1 = longmask[bit_within_word + 26];
      mask2 = longmask[o_bit];

      for (word_value = 64; word_value--;)
        {
          if (word_value & mask1)
            efp_[comes_from_word][word_value][o_long] |= mask2;
        }
    }
}

int
main (void)
{
  compute_extra_tables ();
  puts (file_head);
  dump_do_pc1 ();
  dump_do_pc2 ();
  dump_eperm32tab ();
  dump_efp ();

  if (fflush (stdout) || ferror (stdout) || fclose (stdout))
    {
      perror ("writing extra DES tables");
      return 1;
    }
  return 0;
}
